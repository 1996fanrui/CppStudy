当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。

这些操作称为**拷贝控制操作（copy control）**。

如果一类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

# 拷贝、赋值与销毁

## 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```
class Foo {
public:
    Foo();               // 默认构造函数
    Foo(const Foo&);     // 拷贝构造函数
};
```

**合成拷贝构造函数**

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成拷贝构造函数（synthesized copy constructor）会将其参数的成员逐个拷贝到正在创建的对象中。

每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝；如果数组元素是类类型，则使用元素的拷贝构造函数来逐个进行拷贝。

**拷贝初始化**

拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时会发生，在下列情况下也会发生：

- 将一个对象作为实参传递给一个非引用类型的形参

- 从一个返回类型为非引用类型的函数返回一个对象

- 从花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对它们所分配的对象使用拷贝初始化，如调用标准库容器的insert或push成员时。

## 拷贝赋值运算符

类可以控制其对象如何赋值：

```
Sales_data trans, accum;
trans = accum;    // 使用Sales_data的拷贝赋值运算符
```

**重载赋值运算符**

重载运算符（overloaded operator）本质上是函数，其名字是由operator关键字后接运算符符号组成。因此，赋值运算符就是一个名为operator=的函数。

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```
class Foo {
public:
    Foo& operator=(const Foo&);    // 赋值运算符
};
```

**合成拷贝赋值运算符**

如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。

## 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。

析构函数是一个类的成员函数，名字由一个波浪号接类名构成。它没有返回值，也不接受参数：

```
class Foo {
public:
    ~Foo();    // 析构函数
};
```

由于析构函数不接受参数，因此它不能被重载。一个类只能有一个析构函数。

**析构函数完成什么工作**

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。

通常，析构函数释放对象在生存期分配的所有资源。

析构的部分是隐式的，不存在像构造函数中初始化列表的东西控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

Note：隐式销毁一个内置类型指针的成员不会delete它所指向的对象。

**什么时候会调用析构函数**

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁

- 当一个对象被销毁时，其成员被销毁

- 容器或数组被销毁时，其元素被销毁

- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁

- 对于临时对象，当创建它的完整表达式结束时被销毁

## 三/五法则

C++语言不要求为一个类定义所有的拷贝控制操作，但是这些操作通常应该看成一个整体。

**需要析构函数的类也需要拷贝和赋值操作**

当要决定一个类是否要定义自己的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果需要，那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。

原因分析如下：假如有一个类的构造函数中需要动态分配内存，在析构函数中释放动态内存。如果采用合成的拷贝和赋值操作，那么指向动态内存的指针就会被拷贝，当类的对象释放时，此指针指向的内存可能被释放两次，其结果是未定义的。

**需要拷贝操作的类也需要赋值操作，反之亦然**

如果一个类为一个对象分配一个独有的、唯一的序号。这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象。

此例子引入了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。

## 使用=default

可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。

## 阻止拷贝

当使用某些拷贝控制操作没有合理意义的情况下，定义类时必须采用某种机制加以阻止。比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。

**定义删除的函数**

在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数（deleted function）**来阻止拷贝。

删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。

在函数的参数列表后接=delete来通知编译器，将它定义为删除的：

```
struct NoCopy {
    NoCopy(const NoCopy&) = delete;    // 阻止拷贝
    NoCopy& operator=(const NoCopy&) = delete;    // 阻止赋值
};
```

还可以对任何函数指定=delete。

**析构函数不能是删除的成员**

如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。

**合成的拷贝控制成员可能是删除的**

对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

细节见书本。

**private拷贝控制**

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。

