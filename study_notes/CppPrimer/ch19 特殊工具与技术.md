# 第19章 特殊工具与技术

---

## 控制内存分配

某些程序需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用程序需要重载new运算符和delete运算符以控制内存分配的过程。

### 重载new和delete

当我们使用一条new表达式时：

```c++
string *sp = new string("a value");
string *arr = new string[10];
```

实际执行了三步操作。

0. new表达式调用一个名为operator new(或者operator new[])的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。

0. 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。

0. 对象被分配了空间并构造完成，返回一个指向该对象的指针。

当我们使用一条delete表达式删除一个动态分配的对象时：

```c++
delete sp;
delete [] arr;
```

实际执行了两步操作。

0. 对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。

0. 编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。

如果我们定义了自己版本的operator new函数和operator delete函数，编译器将使用我们自定义的版本替换标准库定义的版本。

!!!warning
	当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为他们是程序整个处理过程中至关重要的一部分。

应用程序可以在全局作用域定义operator new函数和operator delete函数，也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。如果没有找到，编译器在全局作用域查找，如果找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没有找到，则使用标准库定义的版本。

**operator new接口和operator delete接口**

标准库定义了operator new和operator delete的8个重载版本，前四个可能会抛出bad_alloc异常，后四个则不会：

```c++
// 这些版本可能抛出异常
void *operator new(size_t);					// 分配一个对象
void *operator new[](size_t);				// 分配一个数组
void *operator delete(void*) noexcept;		// 释放一个对象
void *operator delete[](void*) noexcept;	// 释放一个数组

// 这些版本承诺不会抛出异常
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&) noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept;
```

当我们将上述函数定义成类的成员时，它们是隐式静态的。更多讨论见p728。

!!!note "new 表达式与operator new函数"
	一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象所占的空间。

	我们提供新的operator new函数和operator delete函数的目的在于改变内存分配方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本含义。

**malloc函数与free函数**

malloc和free定义在cstdlib头文件中。

malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。free函数接受一个void\*，它是malloc返回的指针的副本，free将相关内存返回给系统。调用free(0)没有任何意义。

如下所示是编写operator new和operator delete的一种简单方式，其他版本与之类似：

```c++
void *operator new(size_t size) {
	if (void *mem = malloc(size))
		return mem;
	else
		throw bad_alloc();
}

void operator delete(void *mem) noexcept { free(mem); }
```