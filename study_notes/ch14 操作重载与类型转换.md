#<center>操作重载与类型转换</center>

---

## 基本概念

重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数数量比运算符的运算对象总数少一个。

p491列出了可以重载的运算符。

**直接调用一个重载的运算符函数**

我们能像调用普通函数一样直接调用运算符函数：

```
data1 + data2;				// 普通的表达式
operator+(data1, data2);	// 等价的函数调用

data1 += data2;				// 基于“调用”的表达式
data1.operator+(data2);		// 对成员运算符函数的等价调用
```

**某些运算符不应该被重载**

- 逻辑与、逻辑或运算符，这些运算符指定了运算对象的求值顺序，又因为使用重载的函数运算符本质上是一次函数调用，那么求值顺序的规则无法得到应用。

- 取地址运算符，逗号运算符，C++语言已定义了其特殊含义，不应该被重载，否则其行为将异于常态。

p492讨论了如何选择重载运算符。

**选择作为成员或者非成员**

下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数：

- 赋值（=）、下标（[]）、调用（()）、成员访问箭头（->），必须是成员。

- 复合赋值运算符一般来说应该是成员，但并非必须。

- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。

- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。

## 输入和输出运算符

IO标准库分别使用>>和<<执行输入和输出操作，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。

### 重载输出运算符<<

通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。是非常量是因为向流写入内容会改变其状态；是引用是因为无法复制一个ostream对象。

第二个形参一般来说是一个常量的引用，它是我们想打印的类类型。是引用是因为我们希望避免复制实参；是常量是因为打印对象不会改变对象的内容。

为了与其他输出运算符保持一致，operator<<一般要返回它的ostream形参。

```
ostream &operator<<(ostream &os, const Sales_data &item)
{
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();

	return os;
}
```

【NOTE】通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。

### 重载输入运算符>>

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中。

```
istream& operator>>(istream &is, Sales_data &item)
{
	double price; // 不需要初始化，因为我们将先读入数据到price，之后才使用它
	is >> item.bookNo >> item.units_sold >> price;
	if (is)
		item.revenue = item.units_sold * price;
	else
		item = Sales_data(); // 输入失败：对象被赋予默认状态

	return is;
}
```

【NOTE】输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

## 算术和关系运算符

通常情况下，我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。

如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：

```
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs;		// 把lhs的数据成员拷贝给sum
	sum += rhs;					// 把rhs加到sum中
	return sum;
}
```

### 相等运算符

```
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
	return lhs.isbn() == rhs.isbn() &&
	       lhs.units_sold == rhs.units_sold &&
	       lhs.revenue == rhs.revenue;
}

bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
	return !(lhs == rhs);
}
```

## 赋值运算符

之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。

比如：

```
vector<string> v;
v = {"a", "b", "c"};
```

```
class StrVec {
public:
	StrVec& operator=(std::initializer_list<std::string>)
	{
		// ...
	}
};
```

**复合赋值运算符**

```
// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this;
}
```

## 下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。

为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。

```
class StrVec {
public:
	std::string& operator[](std::size_t n) { return elements[n]; }

	const std::string& operator[](std::size_t n) const { return elements[n]; }

private:
	std::string *elements;	// 指向数组首元素的指针
};
```

## 递增和递减运算符

在迭代器类中通常会实现递增运算符++和递减运算符--，这两种运算符使得类可以在元素的序列中前后移动。

对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。

```
class StrBlobPtr {
public:
	StrBlobPtr& operator++();		// 前置运算符
	StrBlobPtr& operator--();
};
```

**区分前置和后置运算符**

后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。

```
class StrBlobPtr {
public:
	StrBlobPtr operator++(int);		// 后置运算符
	StrBlobPtr operator--(int);
};
```

【NOTE】为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。

## 成员访问运算符

在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。

```
class StrBlobPtr {
public:
	std::string& operator*() const;
	std::string* operator->() const
	{
		// 将实际工作委托给解引用运算符
		return & this->operator*();
	}
};
```

## 函数调用运算符