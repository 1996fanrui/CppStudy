#<center>面向对象程序设计</center>

---

## OOP概述

**面向对象程序设计（object-oriented  programming）**的核心思想是数据抽象、继承和动态绑定。

通过数据抽象，我们可以将类的接口与实现分离。

使用继承，可以定义相似的类型并对其相似关系建模。

使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

**继承**

通过继承（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个基类（base class），其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。

基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

```c++
// 基类的部分定义
class Quote {
public:
	std::string isbn() const;
	virtual double net_price(std::size_t n) const;
};

class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数(virtual function)**。

派生类必须通过使用**类派生列表（class deriveation list）**明确指出它是从哪个基类继承而来的，其形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。

派生类必须在其内部对所有重新定义的虚函数进行声明，最好在后面加上override关键字，以确保编译器为我们做语法检查。

### 定义基类

```c++
class Quote {
public:
	Quote() = default;
	Quote(const std::string &book, double sales_price) : bookNo(book), price(sales_price) {}

	std::string isbn() const { return bookNo; }
	
	virtual ~Quote() = default;	// 对析构函数进行动态绑定
	virtual double net_price(std::size_t n) const { return n * price; }

private:
	std::string bookNo;

protected:
	double price = 0.0;
};
```

【NOTE】基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

**成员函数与继承**

派生类可以继承其基类的成员，但遇到像net_price这样的与类型相关的操作时，派生类必须对其重新定义。即，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来：

- 一种是基类希望其派生类进行覆盖的函数，则将其定义为虚函数。

- 另一种是基类希望派生类直接继承而不要改变的函数。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

**访问控制与继承**

派生类可以继承定义在基类中的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。

派生类能访问公有成员、受保护的成员，不能访问私有成员。

### 定义派生类

```c++
class Bulk_quote : public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const std::string &book, double p, std::size_t qty, double disc) : 
		Quote(book, p), min_qty(qty), discount(disc) {}

	// 覆盖基类的函数版本以实现基于大量购买的折扣政策
	double net_price(std::size_t) const override;

private:
	std::size_t min_qty = 0;	// 适用折扣最低购买量
	double discount = 0.0;		// 折扣
};
```

**派生类中的虚函数**

派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，办法函数后面加一个关键字override。

**派生类对象及派生类向基类的类型转换**

一个派生类对象包含多个组成部分：

- 一个包含派生类自己定义的（非静态）成员的子对象。

- 一个与派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。

C++标准并没有明确规定派生类的对象在内存中如何分布。

我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象的基类部分上。

```
Quote item;				// 基类对象
Bulk_quote bulk;		// 派生类对象
Quote *p = &item;		// p指向Quote对象
p = &bulk;				// p指向bulk的Quote部分
```

这种转换称为**派生类到基类的转换(derived-to-base)**，这是一种隐式转换。

**派生类的构造函数**

尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。

【NOTE】每个类控制它自己的成员初始化过程。