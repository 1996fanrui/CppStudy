# 第十五章 面向对象程序设计

---

## OOP概述

**面向对象程序设计（object-oriented  programming）**的核心思想是数据抽象、继承和动态绑定。

通过数据抽象，我们可以将类的接口与实现分离。

使用继承，可以定义相似的类型并对其相似关系建模。

使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

**继承**

通过继承（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个基类（base class），其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。

基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

```c++
// 基类的部分定义
class Quote {
public:
	std::string isbn() const;
	virtual double net_price(std::size_t n) const;
};

class Bulk_quote : public Quote {
public:
	double net_price(std::size_t) const override;
};
```

对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数(virtual function)**。

派生类必须通过使用**类派生列表（class deriveation list）**明确指出它是从哪个基类继承而来的，其形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。

派生类必须在其内部对所有重新定义的虚函数进行声明，最好在后面加上override关键字，以确保编译器为我们做语法检查。

### 定义基类

```c++
class Quote {
public:
	Quote() = default;
	Quote(const std::string &book, double sales_price) : bookNo(book), price(sales_price) {}

	std::string isbn() const { return bookNo; }
	
	virtual ~Quote() = default;	// 对析构函数进行动态绑定
	virtual double net_price(std::size_t n) const { return n * price; }

private:
	std::string bookNo;

protected:
	double price = 0.0;
};
```

!!!note
	基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

**成员函数与继承**

派生类可以继承其基类的成员，但遇到像net_price这样的与类型相关的操作时，派生类必须对其重新定义。即，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来：

- 一种是基类希望其派生类进行覆盖的函数，则将其定义为虚函数。

- 另一种是基类希望派生类直接继承而不要改变的函数。

当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

**访问控制与继承**

派生类可以继承定义在基类中的成员，但派生类的成员函数不一定有权访问从基类继承而来的成员。

派生类能访问公有成员、受保护的成员，不能访问私有成员。

### 定义派生类

```c++
class Bulk_quote : public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const std::string &book, double p, std::size_t qty, double disc) : 
		Quote(book, p), min_qty(qty), discount(disc) {}

	// 覆盖基类的函数版本以实现基于大量购买的折扣政策
	double net_price(std::size_t) const override;

private:
	std::size_t min_qty = 0;	// 适用折扣最低购买量
	double discount = 0.0;		// 折扣
};
```

**派生类中的虚函数**

派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，办法函数后面加一个关键字override。

**派生类对象及派生类向基类的类型转换**

一个派生类对象包含多个组成部分：

- 一个包含派生类自己定义的（非静态）成员的子对象。

- 一个与派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。

C++标准并没有明确规定派生类的对象在内存中如何分布。

我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象的基类部分上。

```c++
Quote item;				// 基类对象
Bulk_quote bulk;		// 派生类对象
Quote *p = &item;		// p指向Quote对象
p = &bulk;				// p指向bulk的Quote部分
```

这种转换称为**派生类到基类的转换(derived-to-base)**，这是一种隐式转换。

**派生类的构造函数**

尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。

!!!note
	每个类控制它自己的成员初始化过程。

	首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

**继承与静态成员**

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。如果某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。

**防止继承的发生**

有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：

```c++
class NoDerived final { /**/ };			// NoDerived不能作为基类
```

### 类型转换与继承

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清除该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

!!!note
	和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

**静态类型与动态类型**

表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。

动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

```c++
double ret = item.net_price(n);
```

item的静态类型是Quote&，它的动态类型则依赖于item绑定的实参。

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

更多关于基类和派生类之间类型转换的讨论见p534。

## 虚函数

**对虚函数的调用可能在运行时才被解析**

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。

**派生类中的虚函数**

当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。

覆盖的虚函数的形参类型必须与被它覆盖的基类函数完全一致。返回类型也必须与基类函数匹配。

**final和override说明符**

如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的函数，这往往是一种失误，我们原本很可能希望覆盖。

在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数，这么做的好处是编译器可以为我们发现上述错误。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

我们还能把某个函数指定为final，如果函数定义成了final，则之后任何尝试覆盖该函数的操作都将引发错误。

```c++
struct D {
	void f(int) const final;	// 不允许后续的其他类覆盖
}
```

**虚函数与默认实参**

虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定，即使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数机制**

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如：

```c++
double undiscounted = baseP->Quote::net_price(42);
```

该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象到底是什么。该调用将在编译时完成解析。

!!!WARNING
	如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限递归。

## 抽象基类

通过在函数体的位置（即在声明语句的分号）书写=0就可以将一个虚函数说明为纯虚函数。

```c++
double net_price(std::size_t) const = 0;
```

**含有纯虚函数的类是抽象基类**

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。

## 访问控制与继承

每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否**可访问（accessible）**。

**受保护的成员**

一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物：

- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。

- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。

此外，protected还有一条重要的性质：

- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护成员没有任何访问权限。

上述规则可以用下面的例子来理解：

```c++
class Base {
protected:
	int prot_mem;
};

class Sneaky : public Base {
	friend void clobber(Sneaky&);		// 能访问Sneaky::prot_mem
	friend void clobber(Base&);			// 不能访问Base::prot_mem
	int j;								// j默认是private
};

// 正确：clobber能访问Sneaky对象的private和protected成员
void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }

// 错误：clobber不能访问Base的protected成员
void clobber(Base &b) { b.prot_mem = 0; }
```