# 第十六章 模板与泛型编程

模板是C++泛型编程的基础。

模板就是函数或者类的公式，当使用模板时，编译器会把模板转换成特定的类或者函数。

---

## 定义模板

### 函数模板

一个函数模板（function template）就是一个公式，用来生成针对特定类型的函数版本。

一个函数模板可能像下面这样：

```c++
template<typename T>
int template_compare(const T &t1, const T &t2)
{
    if (t1 < t2) return -1;

    if (t1 > t2) return 1;

    return 0;
}
```

template是关键字，之后尖括号内容叫**模板参数列表（template parameter list）**。

!!!note
	在模板定义中，模板参数列表不能为空。

当使用模板时，我们（隐式或显式地）指定模板实参（template argument），将其绑定到模板参数上。

compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。

[==函数模板代码案例==](https://github.com/demon90s/CppPrimer/blob/master/ch16_Templates_and_GenericProgramming/example_function_template.cpp)

**实例化函数模板**

当调用一个函数模板时，编译器会用函数实参推断出模板实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：

```c++
cout << compare(1, 0) << endl;	// T为int
```

函数实参类型是int。编译器推断出模板实参为int，并将它绑定到模板参数T。

编译器用推断出的模板参数实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。

**模板类型参数与非模板参数**

一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。

类型参数前必须使用关键字class或typename。在模板参数列表中，他们的含义没什么不同。但看起来typename更加直观。

除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

**inline和constexpr的函数模板**

可以把函数模板声明成inline或constexpr的，inline或constexpr说明符放在模板参数列表之后，返回类型之前：

```c++
template<typename T> inline T min(const T&, const T&);
```

**模板编译**

编译器遇到模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码。

这一个特性影响到了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器通常需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义。

!!!warning
	保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

### 类模板

类模板（class template）是用来生成类的蓝图的。与函数模板不同之处是，编译器不能为类模板推断模版参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。

类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板的定义中，我们将模版参数当作替身，代替使用模板时用户需要提供的类型或值。

[==类模板案例代码==](https://github.com/demon90s/CppPrimer/blob/master/ch16_Templates_and_GenericProgramming/example_template_class/Blob.h)

**实例化类模板**

当使用一个类模板时，我们必须提供额外信息。这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模版参数。编译器使用这些模板实参来实例化出特定的类。

!!!note
	一个类模板的每个实例都形成一个独立的类。类型`Blob<string>`与任何其他Blob类型都没有关联。

**类模板的成员函数**

我们既可以在类模板的内部，也可以在外部定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和类模板相同的模板参数。

例如对于Blob的成员应该是这样的：

```c++
template<typename T>
ret-type Blob<T>::member_name(parm-list)
```

**模板与友元**

当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。

- 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。

- 如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

**一对一友好关系**

类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：

```c++
// 前置声明，在Blob中声明友元所需要的
template<typename> class BlobPtr;
template<typename> class Blob;		// 运算符==中的参数所需要的
template<typename T> bool operator==(const Blob<T>&, const Blob<T>&);

template<typename T> class Blob {
	// 每个Blob实例将访问权限授予相同类型实例化的BlobPtr和相等运算符
	friend class BlobPtr<T>;
	friend bool operator==<T>(const Blob<T>&, const Blob<T>&)	;
};
```

**通用和特定的模板友好关系**

```c++
// 前置声明，在将模板的一个特定实例声明为友元时要用到
template<typename T> class Pal;

class C {
	friend class Pal<C>;					// 用类C实例化的Pal是C的一个友元
	template<typename T> friend class Pal2; // Pal2的所有实例都是C的友元，这种情况无须前置声明
};
```

**模板类型别名**

我们可以定义一个typedef来引用实例化的类：

```c++
typedef Blob<string> StrBlob;
```

**类模板的static成员**

类模板可以声明static成员：

```c++
template<typename T> class Foo {
public:
	static std::size_t count() { return ctr; }
private:
	static std::size_t ctr;
};

template<typename T>
size_t Foo<T>::ctr = 0; // 定义并初始化ctr
```

每个Foo实例都有其自己的static成员实例。

一个static成员函数只有在使用时才会实例化。

### 模板参数

类似函数参数的名字，一个模板参数的名字没有什么内在的含义。我们可以使用任何名字：

```c++
template <typename Foo> Foo calc(const Foo& a, const Foo& b) {}
```

一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字。而且，在模版内不能重用模版参数名。

```c++
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
	A tmp = a; 	// tmp的类型为模版参数A的类型，而非double
	double B;	// 错误：重声明模板参数B 
}
```

**模板声明**

模板声明必须包含模板参数：

```c++
// 声明但不定义compare和Blob
template <typename T> int compare(const T&, const T&);
template <typename T> class Blob;
```

**使用类的类型成员**

当编译器遇到类似T::mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直到实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。

默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：

```c++
template <typename T>
typename T::value top(const T &c) { /* ... */ }
```

**默认模板实参**

就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参（default template argument）。

例如，可以重写compare，默认使用标准库的less函数对象模板：

```c++
// compare有一个默认模板实参，和一个默认函数实参
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
	if (f(v1, v2)) return -1;
	if (f(v2, v1)) return 1;
	return 0;
}
```

与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

**模板默认实参与类模板**

无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。

如果一个类模板为其所有模版参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个尖括号对：

```c++
template <class T = int>
class Numbers {
public:
	Numbers(T v = 0) : val(v) {}
private:
	T val;
};

Numbers<long long> ll_n;
Numbers<> int_n;	// 空<>表示我们希望使用默认类型
```

### 成员模板

一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。

[==成员模板案例代码==](https://github.com/demon90s/CppPrimer/blob/master/ch16_Templates_and_GenericProgramming/example_member_template/DebugDelete.h)

更多内容详见p596。

### 控制实例化

当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销。

一个显式实例化有如下形式：

```c++
extern template declaration;	// 实例化声明
template declaration;			// 实例化定义
```

declaration是一个类或函数声明，例如：

```c++
extern tempalte class Blob<string>;	// 声明而不实例化

template class Blob<string>;		// 实例化类模板的所有成员
```

当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。

> [==显式实例化案例代码==](https://github.com/demon90s/CppPrimer/tree/master/ch16_Templates_and_GenericProgramming/example_explicit_instantiation)，在这个例子中，我将实例化声明放在头文件里，而将显式的实例化定义放在源文件里。

!!!warning
	对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

显式的实例化定义会实例化所有成员。

关于**效率与灵活性**的详细讨论见p599，书中拿shared_ptr和unique_ptr举例说明，对于shared_ptr，它的删除器需要间接保存（比如为一个指针）；而对于unique_ptr，它的删除器是类类型的一部分，在创建时就必须指定好，可以作为unique_ptr的成员。

- 效率：unique_ptr在编译时绑定了删除器，避免了间接调用删除器的运行时开销。

- 灵活性：shared_ptr在运行时绑定删除器，使用户重载删除器更为方便。

[==自定义的智能指针==](https://github.com/demon90s/CppPrimer/tree/master/ch16_Templates_and_GenericProgramming/example_SmartPointer)可以更直观地解释上述说明。