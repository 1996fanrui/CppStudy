# 第十六章 模板与泛型编程

模板是C++泛型编程的基础。

模板就是函数或者类的公式，当使用模板时，编译器会把模板转换成特定的类或者函数。

---

## 定义模板

### 函数模板

一个函数模板（function template）就是一个公式，用来生成针对特定类型的函数版本。

一个函数模板可能像下面这样：

```c++
template<typename T>
int template_compare(const T &t1, const T &t2)
{
    if (t1 < t2) return -1;

    if (t1 > t2) return 1;

    return 0;
}
```

template是关键字，之后尖括号内容叫**模板参数列表（template parameter list）**。

!!!note
	在模板定义中，模板参数列表不能为空。

当使用模板时，我们（隐式或显式地）指定模板实参（template argument），将其绑定到模板参数上。

compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。

[==函数模板代码案例==](https://github.com/demon90s/CppPrimer/blob/master/ch16_Templates_and_GenericProgramming/example_function_template.cpp)

**实例化函数模板**

当调用一个函数模板时，编译器会用函数实参推断出模板实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：

```c++
cout << compare(1, 0) << endl;	// T为int
```

函数实参类型是int。编译器推断出模板实参为int，并将它绑定到模板参数T。

编译器用推断出的模板参数实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。

**模板类型参数与非模板参数**

一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。

类型参数前必须使用关键字class或typename。在模板参数列表中，他们的含义没什么不同。但看起来typename更加直观。

除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

**inline和constexpr的函数模板**

可以把函数模板声明成inline或constexpr的，inline或constexpr说明符放在模板参数列表之后，返回类型之前：

```c++
template<typename T> inline T min(const T&, const T&);
```

**模板编译**

编译器遇到模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码。

这一个特性影响到了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器通常需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义。

!!!warning
	保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

### 类模板

类模板（class template）是用来生成类的蓝图的。与函数模板不同之处是，编译器不能为类模板推断模版参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。

类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板的定义中，我们将模版参数当作替身，代替使用模板时用户需要提供的类型或值。

[==类模板案例代码==](https://github.com/demon90s/CppPrimer/blob/master/ch16_Templates_and_GenericProgramming/example_template_class/Blob.h)

**实例化类模板**

当使用一个类模板时，我们必须提供额外信息。这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模版参数。编译器使用这些模板实参来实例化出特定的类。

!!!note
	一个类模板的每个实例都形成一个独立的类。类型`Blob<string>`与任何其他Blob类型都没有关联。

**类模板的成员函数**

我们既可以在类模板的内部，也可以在外部定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和类模板相同的模板参数。

例如对于Blob的成员应该是这样的：

```c++
template<typename T>
ret-type Blob<T>::member_name(parm-list)
```

**模板与友元**

当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。

- 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。

- 如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

**一对一友好关系**

类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：

```c++
// 前置声明，在Blob中声明友元所需要的
template<typename> class BlobPtr;
template<typename> class Blob;		// 运算符==中的参数所需要的
template<typename T> bool operator==(const Blob<T>&, const Blob<T>&);

template<typename T> class Blob {
	// 每个Blob实例将访问权限授予相同类型实例化的BlobPtr和相等运算符
	friend class BlobPtr<T>;
	friend bool operator==<T>(const Blob<T>&, const Blob<T>&)	;
};
```

**通用和特定的模板友好关系**

```c++
// 前置声明，在将模板的一个特定实例声明为友元时要用到
template<typename T> class Pal;

class C {
	friend class Pal<C>;					// 用类C实例化的Pal是C的一个友元
	template<typename T> friend class Pal2; // Pal2的所有实例都是C的友元，这种情况无须前置声明
};
```

**模板类型别名**

我们可以定义一个typedef来引用实例化的类：

```c++
typedef Blob<string> StrBlob;
```

**类模板的static成员**

类模板可以声明static成员：

```c++
template<typename T> class Foo {
public:
	static std::size_t count() { return ctr; }
private:
	static std::size_t ctr;
};

template<typename T>
size_t Foo<T>::ctr = 0; // 定义并初始化ctr
```

每个Foo实例都有其自己的static成员实例。

一个static成员函数只有在使用时才会实例化。

### 模板参数