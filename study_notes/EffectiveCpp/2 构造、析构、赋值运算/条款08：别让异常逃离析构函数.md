# 条款08：别让异常逃离析构函数

---

C++并不禁止析构函数吐出异常，但它不鼓励你这样做。因为这可能造成同时存在多个异常，C++认为这太多了。因此只要析构函数吐出了异常，程序可能过早结束或出现不明确的行文。

!!!note
	在CentOS7和VS2015上面测试，都没有办法捕获析构函数吐出的异常，程序结束。

但如果析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，怎么办？这时候可以在析构函数内将异常捕获并处理。

比如：

```c++
DBConn::~DBConn()
{
	try { db.close(); }
	catch (...) {
		// 制作运转记录，记下对close的调用失败
		std::abort();
	}
}
```

一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息！然而有时吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。

还有一个较佳的策略是重新设计DBConn接口，使其客户有机会对可能出现的问题作出反应。比如提供一个close函数，赋予客户一个机会得以处理“因该操作而发生的异常”。DBConn也可以在析构函数中调用close。

```c++
class DBConn
{
public:
	void close()		// 供客户使用的新函数
	{
		db.close();
		closed = true;
	}

	~DBConn()
	{
		if (!closed) {
			try { db.close(); }
			catch (...) {
				// 制作运转记录，记下对close的调用失败
				std::abort();
			}
		}
	}
private:
	DBConnection db;
	bool closed;
}
```

!!!tip "请记住"
	- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
	- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。