[TOC]

# 拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。

类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。

类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

详细讨论见书本和代码案例。

使用这样的例子解释：

```
class HasPtr {
public:
     // 准备定义构造函数、拷贝构造函数、拷贝赋值运算符、析构函数
private:
    std::string *ps;    // 管理的类外资源
    int i;
};
```

## 行为像值的类

对于类管理的资源，每个对象都应该拥有一份自己的拷贝。

为了实现类值的行为，HasPtr需要：

- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针

- 定义一个析构函数来释放string

- 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string

**类值拷贝赋值运算符**

一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。

这样就可以正确进行自赋值操作。

## 定义行为像指针的类

这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。

令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。

但是有时候我们希望直接管理资源，这种情况下，可以使用**引用计数（reference count）**。

**引用计数**

引用计数的工作方式如下：

- 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。

- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。

- 析构函数递减计数器，如果变为0，则析构函数释放状态。

- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。

引用计数应该保存在动态内存中，这样才能保证共享引用计数。

# 交换操作

管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。

如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：

```
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。

```
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

swap函数的存在是为了优化代码。详细定义方法见书本。

**在赋值运算符中使用swap**

定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换（copy and swap）**的技术。

```
HasPtr &HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```

rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。

这种技术自动处理了自赋值的情况且天然就是异常安全的。

# 对象移动

新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。

使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。

## 右值引用

为了支持移动操作，新标准引入了一种新的类型——**右值引用（rvalue reference）**。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。

```
int i = 42;
int &r = i;    // 正确：r引用i
int &&rr = i;  // 错误：不能将一个右值引用绑定到一个左值上
int &&r2 = i * 42; // 正确：将rr2绑定到乘法结果上
```

**左值持久，右值短暂**

左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

**标准库move函数**

虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。

```
int &&rr3 = std::move(i); // OK
```

move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。

## 移动构造函数和移动赋值运算符

移动的版本从给定对象“窃取”资源而不是拷贝资源。

移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。

```
StrVec::StrVec(StrVec &&s) noexcpet // 移动构造函数不应抛出异常
 // 成员初始化器接管s中的资源
 : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    // 令s进入这样的状态——对其运行析构函数是安全的
    s.elements = s.first_free = s.cap = nullptr;
}
```

**移动操作、标准库容器和异常**

移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

通知的方法是在构造函数中指明noexcept。

详细的解释见书本p474。

**移动赋值运算符**

移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：

```
StrVec& StrVec::operator=(StrVec &&rhs) noexcept
{
    // 直接检测自赋值
    if (this != &rhs) {
        free();    // 释放已有资源
        elements = rhs.elements; // 接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        // 将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```